import { Search } from '../search/search';
import { docuvision, elastic } from 'config';
import * as fs from 'fs';
import * as path from 'path';
import { Client as DocuClient } from '../docuvision/docuvision';
import { DocuvisionClient } from '../interfaces';
import { walkPaths, Progress } from '../lib/utils';
import { hashFile } from '../lib/hash';

const index = elastic.index || 'docuvision';

const search = new Search({
    node: elastic.node,
    index,
});

const docuvisionClient = new DocuClient({
    host: docuvision.host,
    apiKey: docuvision.apiKey,
});

const idExists = async (id: string) => {
    const { body } = await search.count({
        body: {
            query: {
                term: {
                    id,
                },
            },
        },
    });
    return 0 !== body.count;
}

const uploadAndWaitForCompletion = async (file: string): Promise<DocuvisionClient.GetDocumentResponse> => {
    const upload = await docuvisionClient.upload({ file });
    return await docuvisionClient.pollForCompletion(upload.body.id);
};

export const indexFile = async (file: string): Promise<DocuvisionClient.GetDocumentResponse & { duration: number; failed?: boolean }> => {
    const hash = await hashFile(file);
    if (await idExists(hash)) {
        return null;
    }

    const start = Date.now();
    const response: DocuvisionClient.GetDocumentResponse & { failed?: boolean } = await uploadAndWaitForCompletion(file).catch(uploadFailure => {
        if (uploadFailure?.body) {
            return { ...uploadFailure, failed: true };
        } else if (uploadFailure instanceof Error) {
            return { message: uploadFailure.message, stack: uploadFailure.stack, failed: true };
        }
        return { uploadFailure, failed: true };
    });

    const duration = Date.now() - start;


    const document = {
        id: hash,
        createdAt: new Date(),
        [!response?.failed ? 'document' : 'error']: !response?.failed ? response.body : response,
        processingTime: duration,
        upload: {
            path: file,
            folder: path.dirname(file),
            filename: path.basename(file),
            extension: path.extname(file),
            size: fs.statSync(file).size,
        },
    };

    await search.index({ body: document });

    if (!response?.failed) {
        const { pages, ...doc } = response.body;

        await Promise.all(
            pages.map(page => search.index({
                const page = {
                    ...document,
                    body: {
                        ...response.body,
                        pages
                    }
                }
                index: `${index}_page`,
                body: { ...doc, page },
            }).catch(console.error)),
        );
    }

    return { ...response, duration };
};

export const indexAllFiles = async (paths: string[]) => {
    if (!await search.client.ping().catch(() => null)) {
        console.error(`Elasticsearch is unreachable (${elastic.node})`);
        process.exit(1);
    }

    await Promise.all([
        search.indicesCreate({ index }).catch(() => null),
        search.indicesCreate({ index: `${index}_page` }).catch(() => null)
    ]);

    const promises: Promise<void>[] = [];

    const progress = new Progress();

    console.log('Processing...');

    for (const file of walkPaths(paths)) {
        progress.total++;
        progress.pending++;
        progress.print();

        const reqStart = Date.now();
        const result = indexFile(file)
            .then(r => {
                progress.pending--;
                if (r === null) {
                    progress.completed++;
                    return;
                }
                progress.time.each[file] = r.duration;
                if (r.failed) {
                    progress.failed++;
                    progress.time.failed.push(r.duration);
                } else {
                    progress.completed++;
                    progress.time.completed.push(r.duration);
                }
            })
            .catch(e => {
                progress.pending--;
                progress.failed++;
                progress.time.each[file] = Date.now() - reqStart;
                progress.print([`error processing ${file}`, e]);
            })
            .then(() => progress.print());

        promises.push(result);
    }

    await Promise.all(promises);

    console.log(`\n\nFinished processing in ${((Date.now() - progress.started) / 1000).toFixed(2)}s. See kibana for full search results`);
    console.log('http://localhost:5601/app/kibana#/dev_tools/console?_g=()');
};
